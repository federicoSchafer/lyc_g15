package lyc.compiler;
import lyc.compiler.files.SymbolTableGenerator;
import java_cup.runtime.*;
import lyc.compiler.model.*;
import java.util.*;

class Parser;

parser code {:
    public SymbolTableGenerator symbolTable = new SymbolTableGenerator(); //Objeto global para la tabla de simbolos
:}


// ===== Símbolos terminales =====
terminal ASSIG, PLUS, SUB, MULT, DIV, OPEN_BRACKET, CLOSE_BRACKET, COMMA, LESS_THAN,
    GREATER_THAN, LESS_THAN_EQUAL, GREATER_THAN_EQUAL, DOBLE_EQUAL, COLON, OPEN_BRACE,
    CLOSE_BRACE, AND, OR, NOT, INT, BOOLEAN, STRING, FLOAT, INIT, WHILE, IF, ELSE, READ, WRITE, EQUAL_EXP, TRIANG_AREA_MAX,
    OPEN_SQUARE_BRACKET, SEMICOLON, CLOSE_SQUARE_BRACKET;
terminal IDENTIFIER;
terminal STRING_CONSTANT;
terminal INTEGER_CONSTANT;
terminal FLOAT_CONSTANT;

// Terminal ficticio para precedencia unaria
terminal UMINUS;

// ===== No terminales =====
non terminal program, statements, statement;
non terminal decl, var_decl;
non terminal id_list;
non terminal type, assignment;
non terminal expr, term, unary_expr, factor, expr_list;
non terminal while, if, read, write, equalexpressions,
    condition, simple_condition;
non terminal triangleareamaximum, triangle, coordinate, coord_list;
// ===== Precedencia =====
precedence left PLUS, SUB;
precedence left MULT, DIV;
precedence right UMINUS;

// ===== Símbolo inicial =====
start with program;

// ===========================
// Gramática
// ===========================

// ---- Programa ----
program ::= decl statements {: System.out.println("[RULE] program -> decl statements"); :} ;

// ---- Lista de statements ----
statements ::= /* vacío */
               {: System.out.println("[RULE] statements -> "); :}
               | statements statement
               {: System.out.println("[RULE] statements -> statements statement"); :} ;

// ---- Statement ----
statement ::= assignment {: System.out.println("[RULE] statement -> assignment"); :}
              | while {: System.out.println("[RULE] statement -> while"); :}
              | if {: System.out.println("[RULE] statement -> if"); :}
              | read {: System.out.println("[RULE] statement -> reader"); :}
              | write {: System.out.println("[RULE] statement -> write"); :}
              | equalexpressions {: System.out.println("[RULE] statement -> equalexpressions"); :}
              | triangleareamaximum {: System.out.println("[RULE] statement -> triangleareamaximum"); :};

// ---- Declaraciones ----
decl ::= INIT OPEN_BRACE var_decl CLOSE_BRACE
           {: System.out.println("[RULE] decl -> INIT { var_decl }"); :} ;

// ---- Declaración de variables ----
var_decl ::= id_list:l COLON type:t
             {:
                System.out.println("[RULE] var_decl -> id_list : type");
                symbolTable.addVariables((List<Object>) l);  // Recibe List<Object>
             :}
           | id_list:l COLON type:t var_decl:vd
             {:
                System.out.println("[RULE] var_decl -> id_list : type var_decl");
                symbolTable.addVariables((List<Object>) l);  // Recibe List<Object>
             :};

// ---- Lista de identificadores ----
id_list ::= IDENTIFIER:s
              {:
                 List<Object> list = new ArrayList<>();
                 list.add(s);
                 RESULT = list;
              :}
          | id_list:l COMMA IDENTIFIER:s
              {:
                 List<Object> list = (List<Object>) l; // casteo explícito
                 list.add(s);
                 RESULT = list;
              :};

// ---- While ----
while ::= WHILE OPEN_BRACKET condition CLOSE_BRACKET OPEN_BRACE statements CLOSE_BRACE
    {: System.out.println("[RULE] while -> WHILE( condition ) { statements }"); :} ;

// ---- If -----
if ::=
           IF OPEN_BRACKET condition CLOSE_BRACKET OPEN_BRACE statements CLOSE_BRACE ELSE OPEN_BRACE statements CLOSE_BRACE
           {: System.out.println("[RULE] if -> IF( condition ) { statements } ELSE { statements }"); :}
         | IF OPEN_BRACKET condition CLOSE_BRACKET OPEN_BRACE statements CLOSE_BRACE
           {: System.out.println("[RULE] if -> IF( condition ) { statements }"); :};


// ---- Read / Write ----
read ::= READ IDENTIFIER
         {: System.out.println("[RULE] reader -> read IDENTIFIER"); :} ;

write ::= WRITE expr
       {: System.out.println("[RULE] write -> write expr"); :} ;


// ---- EqualExpressions ----
equalexpressions ::= IDENTIFIER ASSIG EQUAL_EXP OPEN_BRACKET expr_list CLOSE_BRACKET
    {:
        System.out.println("[RULE] equalexpressions -> IDENTIFIER = EQUAL_EXP( expr_list )");
    :};

// ---- Lista de expresiones ----
expr_list ::= expr:e
    {:
        System.out.println("[RULE] expr_list -> expr");
    :}
    | expr_list:l COMMA expr:e
    {:
        System.out.println("[RULE] expr_list -> expr_list, expr");
    :};

// ---- TriangleAreaMaximum ----
triangleareamaximum ::= IDENTIFIER ASSIG TRIANG_AREA_MAX OPEN_BRACKET triangle SEMICOLON triangle CLOSE_BRACKET
                       {: System.out.println("[RULE] triangleareamaximum -> IDENTIFIER = triangleAreaMaximum( triangle ; triangle )"); :} ;

// ---- Triángulo (definido por 3 coordenadas) ----
triangle ::= OPEN_SQUARE_BRACKET coord_list CLOSE_SQUARE_BRACKET
            {: System.out.println("[RULE] triangle -> [ coord_list ]"); :} ;

// ---- Lista de coordenadas (3 coordenadas para un triángulo) ----
coord_list ::= coordinate
              {: System.out.println("[RULE] coord_list -> coordinate"); :}
             | coord_list SEMICOLON coordinate
              {: System.out.println("[RULE] coord_list -> coord_list ; coordinate"); :} ;

// ---- Coordenada (x,y) ----
coordinate ::= expr COMMA expr
              {: System.out.println("[RULE] coordinate -> expr , expr"); :} ;


// ---- Asignaciones ----
assignment ::= IDENTIFIER ASSIG expr
                {: System.out.println("[RULE] assignment -> IDENTIFIER = expr"); :} ;

// ---- Contion ----
condition ::= simple_condition
              {: System.out.println("[RULE] condition -> simple_condition"); :}
            | simple_condition AND simple_condition
              {: System.out.println("[RULE] condition -> simple_condition AND simple_condition"); :}
            | simple_condition OR simple_condition
              {: System.out.println("[RULE] condition -> simple_condition OR simple_condition"); :}
            | NOT simple_condition
              {: System.out.println("[RULE] condition -> NOT simple_condition"); :};

simple_condition ::= expr GREATER_THAN expr
                     {: System.out.println("[RULE] simple_condition -> expr > expr"); :}
                   | expr LESS_THAN expr
                     {: System.out.println("[RULE] simple_condition -> expr < expr"); :}
                   | expr LESS_THAN_EQUAL expr
                     {: System.out.println("[RULE] simple_condition -> expr <= expr"); :}
                   | expr GREATER_THAN_EQUAL expr
                     {: System.out.println("[RULE] simple_condition -> expr >= expr"); :}
                   | expr DOBLE_EQUAL expr
                     {: System.out.println("[RULE] simple_condition -> expr == expr"); :};



// ---- Expresiones ----
expr ::= expr PLUS term
       {: System.out.println("[RULE] expr -> expr + term"); :}
       | expr SUB term
       {: System.out.println("[RULE] expr -> expr - term"); :}
       | term
       {: System.out.println("[RULE] expr -> term"); :} ;

// ---- Términos ----
term ::= term MULT unary_expr
       {: System.out.println("[RULE] term -> term * unary_expr"); :}
       | term DIV unary_expr
       {: System.out.println("[RULE] term -> term / unary_expr"); :}
       | unary_expr
       {: System.out.println("[RULE] term -> unary_expr"); :} ;

// ---- Expresiones unarias ----
unary_expr ::= SUB factor
             {: System.out.println("[RULE] unary_expr -> - factor"); :} %prec UMINUS
             | PLUS factor
             {: System.out.println("[RULE] unary_expr -> + factor"); :} %prec UMINUS
             | factor
             {: System.out.println("[RULE] unary_expr -> factor"); :} ;

// ---- Factores ----
factor ::= INTEGER_CONSTANT:i
         {: System.out.println("[RULE] factor -> INTEGER_CONSTANT");
            symbolTable.addConstant(i, i);
         :}
         | IDENTIFIER
         {: System.out.println("[RULE] factor -> IDENTIFIER"); :}
         | FLOAT_CONSTANT:f
         {: System.out.println("[RULE] factor -> FLOAT_CONSTANT");
           symbolTable.addConstant(f, f);
         :}
         | STRING_CONSTANT:s
         {: System.out.println("[RULE] factor -> STRING_CONSTANT");
           symbolTable.addConstant(s, s);
         :}
         | OPEN_BRACKET expr CLOSE_BRACKET
         {: System.out.println("[RULE] factor -> (expr)"); :} ;

// ---- Tipos ----
type ::= INT             {: System.out.println("[RULE] type -> INT"); :}
       | BOOLEAN         {: System.out.println("[RULE] type -> BOOLEAN"); :}
       | FLOAT           {: System.out.println("[RULE] type -> FLOAT"); :}
       | STRING          {: System.out.println("[RULE] type -> STRING"); :};
