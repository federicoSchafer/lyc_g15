package lyc.compiler;

import java_cup.runtime.*;
import java.util.*;
import java.util.Stack;
import lyc.compiler.model.*;
import lyc.compiler.files.ArbolSintactico;
import lyc.compiler.files.Nodo;
import lyc.compiler.files.DotFileGenerator;
import lyc.compiler.files.SymbolTableGenerator;

class Parser;

parser code {:
    public SymbolTableGenerator symbolTable = new SymbolTableGenerator();
    public DotFileGenerator syntaxTree;
    public Nodo ptrF;
    public Nodo ptrE;
    public Nodo ptrT;
    public Nodo ptrU;
    public Nodo ptrA;
    Stack<Nodo> pilaE = new Stack<>();
    Stack<Nodo> pilaT = new Stack<>();

:}


// ===== Símbolos terminales =====
terminal ASSIG, PLUS, SUB, MULT, DIV, OPEN_BRACKET, CLOSE_BRACKET, COMMA, LESS_THAN,
    GREATER_THAN, LESS_THAN_EQUAL, GREATER_THAN_EQUAL, DOBLE_EQUAL, COLON, OPEN_BRACE,
    CLOSE_BRACE, AND, OR, NOT, INT, BOOLEAN, STRING, FLOAT, INIT, WHILE, IF, ELSE, READ, WRITE, EQUAL_EXP, TRIANG_AREA_MAX,
    OPEN_SQUARE_BRACKET, SEMICOLON, CLOSE_SQUARE_BRACKET;
terminal IDENTIFIER;
terminal STRING_CONSTANT;
terminal INTEGER_CONSTANT;
terminal FLOAT_CONSTANT;

// Terminal ficticio para precedencia unaria
terminal UMINUS;

// ===== No terminales =====
non terminal program, statements, statement;
non terminal decl, var_decl;
non terminal id_list;
non terminal type, assignment;
non terminal expr, term, unary_expr, factor, expr_list;
non terminal while, if, read, write, equalexpressions,
    condition, simple_condition;
non terminal triangleareamaximum, triangle, coordinate, coord_list;
// ===== Precedencia =====
precedence left PLUS, SUB;
precedence left MULT, DIV;
precedence right UMINUS;

// ===== Símbolo inicial =====
start with program;

// ===========================
// Gramática
// ===========================

// ---- Programa ----
program ::= decl statements {: System.out.println("[RULE] program -> decl statements"); :} ;

// ---- Lista de statements ----
statements ::= statement
               {: System.out.println("[RULE] statements -> statement"); :}
               | statements statement
               {: System.out.println("[RULE] statements -> statements statement"); :} ;

// ---- Statement ----
statement ::= assignment {: System.out.println("[RULE] statement -> assignment"); :}
              | while {: System.out.println("[RULE] statement -> while"); :}
              | if {: System.out.println("[RULE] statement -> if"); :}
              | read {: System.out.println("[RULE] statement -> reader"); :}
              | write {: System.out.println("[RULE] statement -> write"); :}
              | equalexpressions {: System.out.println("[RULE] statement -> equalexpressions"); :}
              | triangleareamaximum {: System.out.println("[RULE] statement -> triangleareamaximum"); :};

// ---- Declaraciones ----
decl ::= INIT OPEN_BRACE var_decl CLOSE_BRACE
           {: System.out.println("[RULE] decl -> INIT { var_decl }"); :} ;

// ---- Declaración de variables ----
var_decl ::= id_list:l COLON type:t
             {:
                System.out.println("[RULE] var_decl -> id_list : type");
                symbolTable.addVariables((List<Object>) l, (Object) t);  // Recibe List<Object>
             :}
           | id_list:l COLON type:t var_decl:vd
             {:
                System.out.println("[RULE] var_decl -> id_list : type var_decl");
                symbolTable.addVariables((List<Object>) l, (Object) t);  // Recibe List<Object>
             :};

// ---- Lista de identificadores ----
id_list ::= IDENTIFIER:s
              {:
                 List<Object> list = new ArrayList<>();
                 list.add(s);
                 RESULT = list;
              :}
          | id_list:l COMMA IDENTIFIER:s
              {:
                 List<Object> list = (List<Object>) l; // casteo explícito
                 list.add(s);
                 RESULT = list;
              :};

// ---- While ----
while ::= WHILE OPEN_BRACKET condition CLOSE_BRACKET OPEN_BRACE statements CLOSE_BRACE
    {: System.out.println("[RULE] while -> WHILE( condition ) { statements }"); :} ;

// ---- If -----
if ::=
           IF OPEN_BRACKET condition CLOSE_BRACKET OPEN_BRACE statements CLOSE_BRACE ELSE OPEN_BRACE statements CLOSE_BRACE
           {: System.out.println("[RULE] if -> IF( condition ) { statements } ELSE { statements }"); :}
         | IF OPEN_BRACKET condition CLOSE_BRACKET OPEN_BRACE statements CLOSE_BRACE
           {: System.out.println("[RULE] if -> IF( condition ) { statements }"); :};


// ---- Read / Write ----
read ::= READ OPEN_BRACKET IDENTIFIER CLOSE_BRACKET
         {: System.out.println("[RULE] reader -> read ( IDENTIFIER )"); :} ;

write ::= WRITE OPEN_BRACKET expr CLOSE_BRACKET
       {: System.out.println("[RULE] write -> write ( expr )"); :} ;


// ---- EqualExpressions ----
equalexpressions ::= IDENTIFIER ASSIG EQUAL_EXP OPEN_BRACKET expr_list CLOSE_BRACKET
    {:
        System.out.println("[RULE] equalexpressions -> IDENTIFIER = EQUAL_EXP( expr_list )");
    :};

// ---- Lista de expresiones ----
expr_list ::= expr:e
    {:
        System.out.println("[RULE] expr_list -> expr");
    :}
    | expr_list:l COMMA expr:e
    {:
        System.out.println("[RULE] expr_list -> expr_list, expr");
    :};

// ---- TriangleAreaMaximum ----
triangleareamaximum ::= IDENTIFIER ASSIG TRIANG_AREA_MAX OPEN_BRACKET triangle SEMICOLON triangle CLOSE_BRACKET
                       {: System.out.println("[RULE] triangleareamaximum -> IDENTIFIER = triangleAreaMaximum( triangle ; triangle )"); :} ;

// ---- Triángulo (definido por 3 coordenadas) ----
triangle ::= OPEN_SQUARE_BRACKET coord_list CLOSE_SQUARE_BRACKET
            {: System.out.println("[RULE] triangle -> [ coord_list ]"); :} ;

// ---- Lista de coordenadas (3 coordenadas para un triángulo) ----
coord_list ::= coordinate SEMICOLON coordinate SEMICOLON coordinate
              {: System.out.println("[RULE] coord_list -> coordinate; coordinate; coordinate"); :};

// ---- Coordenada (x,y) ----
coordinate ::= expr COMMA expr
              {: System.out.println("[RULE] coordinate -> expr , expr"); :} ;


// ---- Asignaciones ----
assignment ::= IDENTIFIER:id ASSIG expr
                {: System.out.println("[RULE] assignment -> IDENTIFIER = expr");
                    ptrA = ArbolSintactico.crearNodo("=", ArbolSintactico.crearHoja(id), ptrE);
                    syntaxTree = new DotFileGenerator(ptrA); //Esta linea genera el archivoDot (cambiarla de lugar segun lo que se desee probar)
                :} ;

// ---- Contion ----
condition ::= simple_condition
              {: System.out.println("[RULE] condition -> simple_condition"); :}
            | simple_condition AND simple_condition
              {: System.out.println("[RULE] condition -> simple_condition AND simple_condition"); :}
            | simple_condition OR simple_condition
              {: System.out.println("[RULE] condition -> simple_condition OR simple_condition"); :}
            | NOT simple_condition
              {: System.out.println("[RULE] condition -> NOT simple_condition"); :};

simple_condition ::= expr GREATER_THAN expr
                     {: System.out.println("[RULE] simple_condition -> expr > expr"); :}
                   | expr LESS_THAN expr
                     {: System.out.println("[RULE] simple_condition -> expr < expr"); :}
                   | expr LESS_THAN_EQUAL expr
                     {: System.out.println("[RULE] simple_condition -> expr <= expr"); :}
                   | expr GREATER_THAN_EQUAL expr
                     {: System.out.println("[RULE] simple_condition -> expr >= expr"); :}
                   | expr DOBLE_EQUAL expr
                     {: System.out.println("[RULE] simple_condition -> expr == expr"); :};



// ---- Expresiones ----
expr ::= expr {: pilaE.push(ptrE); :} PLUS term
       {: System.out.println("[RULE] expr -> expr + term");
          ptrE = pilaE.pop();
          ptrE = ArbolSintactico.crearNodo("+", ptrE, ptrT);
       :}
       | expr {: pilaE.push(ptrE); :} SUB term
       {: System.out.println("[RULE] expr -> expr - term");
         ptrE = pilaE.pop();
         ptrE = ArbolSintactico.crearNodo("-", ptrE, ptrT);
       :}
       | term
       {: System.out.println("[RULE] expr -> term");
          ptrE = ptrT;
       :} ;

// ---- Términos ----
term ::= term {: pilaT.push(ptrT); :} MULT unary_expr
       {: System.out.println("[RULE] term -> term * unary_expr");
          ptrT = pilaT.pop();
          ptrT = ArbolSintactico.crearNodo("*", ptrT, ptrU);
       :}
       | term {: pilaT.push(ptrT); :} DIV unary_expr
       {: System.out.println("[RULE] term -> term / unary_expr");
         ptrT = pilaT.pop();
         ptrT = ArbolSintactico.crearNodo("/", ptrT, ptrU);
       :}
       | unary_expr
       {: System.out.println("[RULE] term -> unary_expr");
          ptrT = ptrU;
       :} ;

// ---- Expresiones unarias ----
unary_expr ::= SUB factor
             {: System.out.println("[RULE] unary_expr -> - factor");
                ptrU = ArbolSintactico.crearNodo("U", ArbolSintactico.crearHoja("-"), ptrF);
             :} %prec UMINUS
             | PLUS factor
             {: System.out.println("[RULE] unary_expr -> + factor");
               ptrU = ArbolSintactico.crearNodo("U", ArbolSintactico.crearHoja("+"), ptrF);
             :} %prec UMINUS
             | factor
             {: System.out.println("[RULE] unary_expr -> factor");
                ptrU = ptrF;
             :} ;

// ---- Factores ----
factor ::= INTEGER_CONSTANT:cte
         {: System.out.println("[RULE] factor -> INTEGER_CONSTANT");
            symbolTable.addConstant(cte, cte, "int");
            ptrF = ArbolSintactico.crearHoja(cte);
         :}
         | IDENTIFIER:id
         {: System.out.println("[RULE] factor -> IDENTIFIER");
            ptrF = ArbolSintactico.crearHoja(id);
         :}
         | FLOAT_CONSTANT:cte
         {: System.out.println("[RULE] factor -> FLOAT_CONSTANT");
           symbolTable.addConstant(cte, cte, "float");
           ptrF = ArbolSintactico.crearHoja(cte);
         :}
         | STRING_CONSTANT:cte
         {: System.out.println("[RULE] factor -> STRING_CONSTANT");
           symbolTable.addConstant(cte, cte, "string");
           ptrF = ArbolSintactico.crearHoja(cte);
         :}
         | OPEN_BRACKET expr CLOSE_BRACKET:exp
         {: System.out.println("[RULE] factor -> (expr)");
            ptrF = ptrE;
         :};

// ---- Tipos ----
type ::= INT             {: System.out.println("[RULE] type -> INT");
                               RESULT = "int";
                         :}
       | BOOLEAN         {: System.out.println("[RULE] type -> BOOLEAN");
                               RESULT = "boolean";
                         :}
       | FLOAT           {: System.out.println("[RULE] type -> FLOAT");
                               RESULT = "float";
                         :}
       | STRING          {: System.out.println("[RULE] type -> STRING");
                               RESULT = "string";
                         :};
